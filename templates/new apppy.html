import os
import json
import csv
import uuid
from datetime import datetime, timedelta
from functools import wraps
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import secure_filename
from flask import Flask, render_template, redirect, url_for, flash, request, session, jsonify, make_response, g, Response, send_file
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from collections import defaultdict

# --- Configuration ---
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'a_very_secret_key_that_should_be_replaced_in_production')
app.config['UPLOAD_FOLDER'] = 'static/uploads'
app.config['PRODUCT_IMAGES_FOLDER'] = os.path.join(app.config['UPLOAD_FOLDER'], 'product_images')
app.config['CATEGORY_IMAGES_FOLDER'] = os.path.join(app.config['UPLOAD_FOLDER'], 'category_images')
app.config['PAYMENT_SCREENSHOTS_FOLDER'] = os.path.join(app.config['UPLOAD_FOLDER'], 'payment_screenshots')
app.config['INVOICE_PDF_FOLDER'] = os.path.join(app.config['UPLOAD_FOLDER'], 'invoices')

# Ensure upload folders exist
os.makedirs(app.config['PRODUCT_IMAGES_FOLDER'], exist_ok=True)
os.makedirs(app.config['CATEGORY_IMAGES_FOLDER'], exist_ok=True)
os.makedirs(app.config['PAYMENT_SCREENSHOTS_FOLDER'], exist_ok=True)
os.makedirs(app.config['INVOICE_PDF_FOLDER'], exist_ok=True)

# --- Constants ---
DEFAULT_SHIPPING_CHARGE = 50.00
MAX_SHIPPING_COST_FREE_THRESHOLD = 5000.00 # Orders above this amount get free shipping
DEFAULT_GST_PERCENTAGE = 18.0 # Default GST for products if not specified
DEFAULT_INVOICE_GST_RATE = 18.0 # Default GST rate applied to invoices

# Our Business Details for Invoices (configurable)
OUR_BUSINESS_NAME = "Karthika Futures"
OUR_GSTIN = "27ABCDE1234F1Z5" # Example GSTIN
OUR_PAN = "ABCDE1234F" # Example PAN
OUR_BUSINESS_ADDRESS = "No. 123, Temple Road, Spiritual City, Karnataka - 560001"
OUR_BUSINESS_EMAIL = "invoices@karthikafutures.com" # Email for sending invoices

# --- Login Manager Setup ---
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'user_login' # Redirect to login page if not authenticated
login_manager.login_message = "Please log in to access this page."
login_manager.login_message_category = "info"

# --- User Model ---
class User(UserMixin):
    def __init__(self, id, email, password, name, phone=None, address=None, pincode=None, role='user'):
        self.id = str(id) # Ensure ID is string for Flask-Login
        self.email = email
        self.password = password
        self.name = name
        self.phone = phone
        self.address = address
        self.pincode = pincode
        self.role = role # 'user' or 'admin'

    def is_admin(self):
        return self.role == 'admin'

    @staticmethod
    def get(user_id):
        users = load_json('users.json')
        for user_data in users:
            if str(user_data['id']) == str(user_id):
                return User(**user_data)
        return None

    @staticmethod
    def find_by_email(email):
        users = load_json('users.json')
        for user_data in users:
            if user_data['email'] == email:
                return User(**user_data)
        return None

@login_manager.user_loader
def load_user(user_id):
    return User.get(user_id)

# --- Decorators ---
def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_admin():
            flash('You do not have permission to access this page.', 'danger')
            return redirect(url_for('user_login'))
        return f(*args, **kwargs)
    return decorated_function

# --- Helper Functions for JSON Data Management ---
def load_json(filename):
    filepath = os.path.join('data', filename)
    if not os.path.exists(filepath):
        # Create empty file with appropriate structure if it doesn't exist
        if filename == 'users.json':
            initial_data = []
        elif filename == 'artworks.json':
            initial_data = []
        elif filename == 'orders.json':
            initial_data = []
        elif filename == 'categories.json':
            initial_data = []
        else:
            initial_data = {} # Default to empty dict for other JSONs

        os.makedirs('data', exist_ok=True) # Ensure 'data' directory exists
        with open(filepath, 'w') as f:
            json.dump(initial_data, f, indent=4)
        return initial_data
    with open(filepath, 'r') as f:
        return json.load(f)

def save_json(filename, data):
    filepath = os.path.join('data', filename)
    with open(filepath, 'w') as f:
        json.dump(data, f, indent=4)

# Specific Loaders (Recommended for clarity, ensure these exist and use load_json)
def load_categories_data():
    return load_json('categories.json')

def load_artworks_data():
    return load_json('artworks.json')

def load_users_data():
    return load_json('users.json')

def load_orders_data():
    return load_json('orders.json')

# --- Context Processor to pass global data to all templates ---
@app.context_processor
def inject_global_data():
    categories = load_categories_data() # Use the specific loader
    
    # Placeholder for testimonials data (you might load this from a JSON file later)
    testimonials = [
        {
            'name': 'Radha Devi',
            'image': url_for('static', filename='uploads/testimonial_radha.jpg'),
            'rating': 5,
            'feedback': 'The Krishna painting I received is absolutely divine. It brings so much peace to my home. Highly recommend!',
            'product_sku': 'KP001' # Optional: SKU of product reviewed
        },
        {
            'name': 'Arjuna Sharma',
            'image': url_for('static', filename='uploads/testimonial_arjuna.jpg'),
            'rating': 4,
            'feedback': 'Beautiful craftsmanship on the statue. Delivery was prompt and packaging was secure.',
            'product_sku': 'MS002'
        },
        {
            'name': 'Sita Rani',
            'image': url_for('static', filename='uploads/testimonial_sita.jpg'),
            'rating': 5,
            'feedback': 'The personalized options are fantastic! My framed artwork looks stunning.',
            'product_sku': 'PA003'
        },
        {
            'name': 'Krishna Prasad',
            'image': url_for('static', filename='uploads/testimonial_krishna.jpg'),
            'rating': 5,
            'feedback': 'A true treasure! The quality of the print and the intricate details are mesmerizing.',
            'product_sku': 'PG004'
        }
    ]
    
    # Ensure testimonial images exist or use a generic placeholder
    for t in testimonials:
        # Construct the full path to check for file existence
        # Assumes images are in static/uploads or static/images
        # This handles both cases more robustly
        
        # Split the URL to get the relative path from static/
        if t['image'].startswith('/static/'):
            relative_path_from_static = t['image'][len('/static/'):]
        else: # Assume it's already a relative path if not starting with /static/
            relative_path_from_static = t['image']

        full_image_path = os.path.join(app.root_path, 'static', relative_path_from_static)

        if not os.path.exists(full_image_path):
            t['image'] = url_for('static', filename='images/user-placeholder.png') # Fallback placeholder

    return dict(
        categories=categories,
        current_user=current_user,
        current_year=datetime.now().year,
        testimonials=testimonials,
        MAX_SHIPPING_COST_FREE_THRESHOLD=MAX_SHIPPING_COST_FREE_THRESHOLD,
        our_business_name=OUR_BUSINESS_NAME,
        our_gstin=OUR_GSTIN,
        our_pan=OUR_PAN,
        our_business_address=OUR_BUSINESS_ADDRESS,
        our_business_email=OUR_BUSINESS_EMAIL,
        default_gst_rate=DEFAULT_INVOICE_GST_RATE,
        now=datetime.now # For invoice date default
    )

# --- Core Logic for Price & Cart Calculation ---

def calculate_item_price_with_options(artwork, size_option, frame_option, glass_option):
    """Calculates the unit price of an artwork based on selected options (before GST)."""
    unit_price = artwork.get('original_price', 0.0)

    # Only apply options if the artwork is a 'Painting'
    if artwork.get('category') == 'Paintings':
        # Add size price
        if size_option == 'A4':
            unit_price += artwork.get('size_a4', 0.0)
        elif size_option == 'A5':
            unit_price += artwork.get('size_a5', 0.0)
        elif size_option == 'Letter':
            unit_price += artwork.get('size_letter', 0.0)
        elif size_option == 'Legal':
            unit_price += artwork.get('size_legal', 0.0)
        # 'Original' size means no extra charge (price already includes artwork.original_price)

        # Add frame price
        if frame_option == 'Wooden':
            unit_price += artwork.get('frame_wooden', 0.0)
        elif frame_option == 'Metal':
            unit_price += artwork.get('frame_metal', 0.0)
        elif frame_option == 'PVC':
            unit_price += artwork.get('frame_pvc', 0.0)
        # 'None' frame means no extra charge

        # Add glass price
        if glass_option == 'Standard': # Using 'Standard' as option value for "With Glass"
            unit_price += artwork.get('glass_price', 0.0)
        # 'None' glass means no extra charge

    return round(unit_price, 2)

def calculate_cart_totals(current_cart_session, artworks_data):
    """
    Recalculates all totals for the cart, including GST and shipping.
    Takes the raw session cart (dict of items) and all artworks data.
    Returns a dict with updated cart items, subtotal, GST, shipping, and grand total.
    Important: This function will also adjust quantities in `current_cart_session` if they exceed stock.
    """
    subtotal_before_gst = 0.0
    total_gst_amount = 0.0
    shipping_charge = 0.0
    
    # Process items to get accurate prices, GST, and stock
    processed_cart_items = []
    items_to_remove = [] # Track items that should be removed due to 0 quantity/stock
    
    for item_id, item_data_original in current_cart_session.items():
        # Ensure item_data is a mutable copy for modification within this function
        item_data = item_data_original.copy()
        
        artwork_sku = item_data.get('sku')
        artwork_info = next((a for a in artworks_data if a.get('sku') == artwork_sku), None)

        if not artwork_info:
            print(f"WARNING: Artwork SKU {artwork_sku} not found in artworks.json. Marking item for removal from cart.")
            items_to_remove.append(item_id)
            continue # Skip to next item if artwork not found

        item_quantity = int(item_data.get('quantity', 1))
        
        # Determine actual available stock for real-time check
        stock_available = artwork_info.get('stock', 0)

        # Clamp quantity to available stock (and ensure non-negative)
        if item_quantity > stock_available:
            item_quantity = stock_available # Clamp quantity to available stock
            flash(f"Quantity for '{artwork_info.get('name')}' adjusted to available stock: {stock_available}", 'warning')
        
        # If item quantity becomes 0 due to clamping, or was already 0/negative, mark for removal
        if item_quantity <= 0:
            items_to_remove.append(item_id)
            if stock_available == 0:
                flash(f"'{artwork_info.get('name')}' is out of stock and removed from cart.", 'danger')
            else: # If quantity was zero or negative for some reason, remove it
                flash(f"'{artwork_info.get('name')}' quantity was invalid and removed from cart.", 'danger')
            continue # Skip further processing for this item

        # Recalculate unit price based on selected options and original prices from artworks_data
        unit_price_before_gst = calculate_item_price_with_options(
            artwork_info,
            item_data.get('size'),
            item_data.get('frame'),
            item_data.get('glass') # This should be 'Standard' or 'None'
        )
        
        gst_percentage = artwork_info.get('gst_percentage', DEFAULT_GST_PERCENTAGE)
        
        item_total_price_before_gst = unit_price_before_gst * item_quantity
        item_gst_amount = item_total_price_before_gst * (gst_percentage / 100)
        item_total_price_with_gst = item_total_price_before_gst + item_gst_amount

        # Update item_data with recalculated values and current stock
        item_data['unit_price_before_gst'] = unit_price_before_gst
        item_data['total_price_before_gst'] = round(item_total_price_before_gst, 2)
        item_data['gst_percentage'] = round(gst_percentage, 2)
        item_data['gst_amount'] = round(item_gst_amount, 2)
        item_data['total_price'] = round(item_total_price_with_gst, 2)
        item_data['stock_available'] = stock_available # Add stock for client-side validation
        item_data['quantity'] = item_quantity # Ensure quantity reflects any clamping

        subtotal_before_gst += item_total_price_before_gst
        total_gst_amount += item_gst_amount
        
        processed_cart_items.append(item_data)

    # Remove items marked for removal from the actual session cart
    for item_id_to_remove in items_to_remove:
        if item_id_to_remove in current_cart_session:
            del current_cart_session[item_id_to_remove]
    
    # Update session cart with processed items (to reflect quantity clamps, etc.)
    # We rebuild the session cart to ensure consistency
    session['cart'] = {item['id']: item for item in processed_cart_items}

    # Apply shipping charge based on final subtotal
    if subtotal_before_gst > 0 and subtotal_before_gst < MAX_SHIPPING_COST_FREE_THRESHOLD:
        shipping_charge = DEFAULT_SHIPPING_CHARGE
    else:
        shipping_charge = 0.0 # Free shipping or no items

    cgst_amount = total_gst_amount / 2
    sgst_amount = total_gst_amount / 2
    grand_total = subtotal_before_gst + total_gst_amount + shipping_charge

    return {
        'cart_items': processed_cart_items, # Return the list of processed items
        'subtotal_before_gst': round(subtotal_before_gst, 2),
        'total_gst_amount': round(total_gst_amount, 2),
        'cgst_amount': round(cgst_amount, 2),
        'sgst_amount': round(sgst_amount, 2),
        'shipping_charge': round(shipping_charge, 2),
        'grand_total': round(grand_total, 2)
    }

# --- Routes ---

@app.route('/')
def index():
    artworks = load_artworks_data() # Use the specific loader
    
    # Filter and categorize artworks for the homepage display
    featured_artworks = [art for art in artworks if art.get('is_featured')] # Assuming a 'is_featured' flag
    
    # Group artworks by category
    artworks_by_category = defaultdict(list)
    for art in artworks:
        category = art.get('category', 'Uncategorized')
        # Only show a few from each category on homepage, maybe limit to 6
        if len(artworks_by_category[category]) < 6: # You can adjust this limit
            artworks_by_category[category].append(art)
    
    # Convert defaultdict to regular dict for rendering, and ensure 'Paintings' comes first if exists
    # And sort other categories alphabetically
    ordered_categories = sorted(artworks_by_category.keys(), key=lambda x: (0, x) if x == 'Paintings' else (1, x))
    artworks_by_category_dict = {cat: artworks_by_category[cat] for cat in ordered_categories}

    return render_template('index.html',
                           featured_artworks=featured_artworks,
                           artworks_by_category=artworks_by_category_dict)

@app.route('/all-products')
def all_products():
    artworks = load_artworks_data() # Use the specific loader
    # Sort artworks alphabetically by name for a consistent display
    sorted_artworks = sorted(artworks, key=lambda x: x.get('name', ''))
    return render_template('all_products.html', artworks=sorted_artworks)

@app.route('/product/<sku>')
def product_detail(sku):
    artworks = load_artworks_data() # Use the specific loader
    artwork = next((a for a in artworks if a['sku'] == sku), None)
    if not artwork:
        flash('Artwork not found.', 'danger')
        return redirect(url_for('all_products'))
    return render_template('product_detail.html', artwork=artwork)

# --- Cart & Checkout Routes ---

@app.route('/add_to_cart', methods=['POST'])
def add_to_cart():
    # This route is now primarily used by the product_detail page AJAX,
    # and the global addToCart function in _base.html
    data = request.get_json()
    sku = data.get('sku')
    selected_size = data.get('size')
    selected_frame = data.get('frame')
    selected_glass = data.get('glass')
    quantity = int(data.get('quantity', 1))

    artworks_data = load_artworks_data() # Use the specific loader
    artwork_info = next((a for a in artworks_data if a.get('sku') == sku), None)

    if not artwork_info:
        return jsonify(success=False, message="Artwork not found."), 404

    current_stock = artwork_info.get('stock', 0)
    if current_stock == 0:
        return jsonify(success=False, message="This item is currently out of stock."), 400
    if quantity <= 0:
        return jsonify(success=False, message="Quantity must be at least 1."), 400

    # Calculate unit price based on selected options
    unit_price_before_gst = calculate_item_price_with_options(artwork_info, selected_size, selected_frame, selected_glass)
    gst_percentage = artwork_info.get('gst_percentage', DEFAULT_GST_PERCENTAGE)

    # Construct a unique item ID for the cart, considering options
    item_id = f"{sku}-{selected_size}-{selected_frame}-{selected_glass}"

    cart = session.get('cart', {})
    
    # Ensure cart is a dictionary
    if not isinstance(cart, dict):
        cart = {}
        session['cart'] = cart

    if item_id in cart:
        # If item already in cart, update quantity and re-calculate its total price components
        new_quantity = cart[item_id].get('quantity', 0) + quantity
        if new_quantity > current_stock:
            return jsonify(success=False, message=f"Adding {quantity} more would exceed available stock. Only {current_stock - cart[item_id].get('quantity', 0)} more available.", current_quantity=cart[item_id].get('quantity', 0), stock=current_stock), 400
        
        cart[item_id]['quantity'] = new_quantity
        cart[item_id]['unit_price_before_gst'] = unit_price_before_gst # Recalculate based on latest artwork info
        cart[item_id]['total_price_before_gst'] = unit_price_before_gst * new_quantity
        cart[item_id]['gst_percentage'] = gst_percentage
        cart[item_id]['gst_amount'] = (unit_price_before_gst * new_quantity) * (gst_percentage / 100)
        cart[item_id]['total_price'] = cart[item_id]['total_price_before_gst'] + cart[item_id]['gst_amount']
        cart[item_id]['stock_available'] = current_stock # Add stock info for JS
    else:
        # Add new item to cart
        if quantity > current_stock:
            return jsonify(success=False, message=f"Quantity requested ({quantity}) exceeds available stock ({current_stock}).", stock=current_stock), 400

        cart[item_id] = {
            'id': item_id,
            'sku': sku,
            'name': artwork_info.get('name'),
            'image': artwork_info.get('images', [None])[0], # Get first image path
            'category': artwork_info.get('category'),
            'size': selected_size,
            'frame': selected_frame,
            'glass': selected_glass,
            'quantity': quantity,
            'unit_price_before_gst': unit_price_before_gst,
            'gst_percentage': gst_percentage,
            'total_price_before_gst': unit_price_before_gst * quantity,
            'gst_amount': (unit_price_before_gst * quantity) * (gst_percentage / 100),
            'total_price': (unit_price_before_gst * quantity) + ((unit_price_before_gst * quantity) * (gst_percentage / 100)),
            'stock_available': current_stock # Add stock info for JS
        }
    
    session['cart'] = cart
    # Recalculate global cart totals after adding/updating item
    updated_summary = calculate_cart_totals(session.get('cart', {}), artworks_data)

    return jsonify(success=True, message=f"'{artwork_info.get('name')}' added to cart!", cart_count=len(session['cart']), **updated_summary)


@app.route('/update_cart_session', methods=['POST'])
def update_cart_session():
    """
    Endpoint for client-side JS to sync its local cart state with the server session.
    Can also be used to simply fetch the latest server cart state if no 'cart' is provided in payload.
    """
    data = request.get_json()
    client_cart = data.get('cart') # This is the cart object from client-side sessionStorage

    artworks_data = load_artworks_data() # Use the specific loader

    if client_cart is not None:
        # If client sends a cart, update the server's session cart with it
        # Ensure quantities are valid and prices are consistent with server data
        updated_server_cart = {}
        for item_id, item_data in client_cart.items():
            sku = item_data.get('sku')
            artwork_info = next((a for a in artworks_data if a.get('sku') == sku), None)

            if artwork_info:
                # Re-calculate prices and validate quantity based on server's artwork data
                unit_price_before_gst = calculate_item_price_with_options(
                    artwork_info,
                    item_data.get('size'),
                    item_data.get('frame'),
                    item_data.get('glass')
                )
                gst_percentage = artwork_info.get('gst_percentage', DEFAULT_GST_PERCENTAGE)
                stock_available = artwork_info.get('stock', 0)
                
                quantity = int(item_data.get('quantity', 0))
                if quantity > stock_available:
                    quantity = stock_available # Clamp to available stock
                    flash(f"Quantity for '{artwork_info.get('name')}' adjusted to available stock: {stock_available}", 'warning')
                if quantity <= 0 and stock_available > 0: # Ensure at least 1 if stock exists
                    quantity = 1
                    flash(f"Quantity for '{artwork_info.get('name')}' adjusted to minimum 1.", 'info')
                if stock_available == 0: # If item is genuinely out of stock, set quantity to 0
                    quantity = 0

                if quantity > 0: # Only add to updated_server_cart if quantity is positive
                    item_total_price_before_gst = unit_price_before_gst * quantity
                    item_gst_amount = item_total_price_before_gst * (gst_percentage / 100)
                    item_total_price_with_gst = item_total_price_before_gst + item_gst_amount

                    updated_server_cart[item_id] = {
                        'id': item_id,
                        'sku': sku,
                        'name': artwork_info.get('name'),
                        'image': artwork_info.get('images', [None])[0],
                        'category': artwork_info.get('category'),
                        'size': item_data.get('size'),
                        'frame': item_data.get('frame'),
                        'glass': item_data.get('glass'),
                        'quantity': quantity,
                        'unit_price_before_gst': unit_price_before_gst,
                        'gst_percentage': gst_percentage,
                        'total_price_before_gst': item_total_price_before_gst,
                        'gst_amount': item_gst_amount,
                        'total_price': item_total_price_with_gst,
                        'stock_available': stock_available # Pass available stock
                    }
                else:
                    flash(f"'{artwork_info.get('name')}' is out of stock or quantity is zero and has been removed from cart.", 'danger')


            else:
                # If artwork not found in our database, remove from cart
                flash(f"An item in your cart (SKU: {sku}) was not found and has been removed.", 'warning')
        
        session['cart'] = updated_server_cart
    else:
        # If no client_cart is provided, just re-validate the existing server cart
        # This is useful when the client just wants to fetch the latest server-validated state
        pass # The calculate_cart_totals will automatically work on existing session['cart']

    # Always return the calculated totals based on the server's current session cart
    cart_summary = calculate_cart_totals(session.get('cart', {}), artworks_data)
    
    return jsonify(success=True, message="Cart synchronized.", **cart_summary)


@app.route('/cart')
def cart():
    artworks_data = load_artworks_data() # Use the specific loader
    cart_data_from_session = session.get('cart', {})

    # Ensure cart_data_from_session is a dictionary
    if not isinstance(cart_data_from_session, dict):
        cart_data_from_session = {}
        session['cart'] = cart_data_from_session 

    # Recalculate totals and items for display based on the session cart
    # This also handles stock clamping and removing items with zero quantity/stock
    cart_summary = calculate_cart_totals(cart_data_from_session, artworks_data)
    
    # If, after recalculation, the cart is empty, redirect
    if not cart_summary['cart_items'] and cart_data_from_session: # Only redirect if it *was* not empty
        flash('Your cart is empty or all items are out of stock. Please add items to proceed.', 'info')
        return redirect(url_for('all_products'))
    elif not cart_summary['cart_items']: # If cart was already empty
        return render_template('cart.html', cart_items=[], subtotal_before_gst=0.0, total_gst_amount=0.0, cgst_amount=0.0, sgst_amount=0.0, shipping_charge=0.0, grand_total=0.0)


    return render_template('cart.html',
                           cart_items=cart_summary['cart_items'],
                           subtotal_before_gst=cart_summary['subtotal_before_gst'],
                           total_gst_amount=cart_summary['total_gst_amount'],
                           cgst_amount=cart_summary['cgst_amount'],
                           sgst_amount=cart_summary['sgst_amount'],
                           shipping_charge=cart_summary['shipping_charge'],
                           grand_total=cart_summary['grand_total'],
                           MAX_SHIPPING_COST_FREE_THRESHOLD=MAX_SHIPPING_COST_FREE_THRESHOLD)

@app.route('/update_cart_item_quantity', methods=['POST'])
def update_cart_item_quantity():
    try:
        data = request.get_json()
        item_id = data.get('itemId')
        new_quantity = int(data.get('newQuantity'))

        if not item_id or new_quantity is None:
            return jsonify(success=False, message="Invalid request data."), 400

        current_cart_session = session.get('cart', {})
        if item_id not in current_cart_session:
            return jsonify(success=False, message="Item not found in cart."), 404

        artworks_data = load_artworks_data() # Use the specific loader
        artwork_sku = current_cart_session[item_id].get('sku')
        artwork_info = next((a for a in artworks_data if a.get('sku') == artwork_sku), None)

        if not artwork_info:
            return jsonify(success=False, message="Artwork details not found for cart item."), 404
        
        available_stock = artwork_info.get('stock', 0)

        # Logic for quantity update, clamping to stock or removal
        if new_quantity < 1:
            if item_id in current_cart_session: # Ensure it's still there before deleting
                del current_cart_session[item_id]
                session['cart'] = current_cart_session # Update session immediately
                message = "Item removed from cart."
            else:
                message = "Item already removed from cart." # Should not happen with proper flow
            flash(message, "info") # Flash message for removal

        elif new_quantity > available_stock:
            current_cart_session[item_id]['quantity'] = available_stock
            session['cart'] = current_cart_session
            message = f"Only {available_stock} of {artwork_info.get('name')} available. Quantity adjusted."
            flash(message, "warning")
            print(f"WARNING: Requested quantity {new_quantity} for {item_id} exceeds stock {available_stock}. Adjusted to {available_stock}.")

        else:
            current_cart_session[item_id]['quantity'] = new_quantity
            session['cart'] = current_cart_session
            message = "Cart updated."

        # Recalculate totals after modification (this also updates session['cart'])
        updated_cart_summary = calculate_cart_totals(session.get('cart', {}), artworks_data)
        
        # Ensure the item is still in the cart if its quantity is > 0
        if new_quantity >= 1: # If new_quantity is at least 1, we expect it to be in updated_cart_summary['cart_items']
            updated_item_in_summary = next((item for item in updated_cart_summary['cart_items'] if item['id'] == item_id), None)
            if updated_item_in_summary:
                return jsonify(success=True, message=message, **updated_cart_summary)
            else: # Item might have been removed from summary due to 0 stock
                return jsonify(success=True, message=f"Item removed due to 0 stock: {artwork_info.get('name')}.", **updated_cart_summary)

        return jsonify(success=True, message=message, **updated_cart_summary), 200 # Return 200 even if removed

    except Exception as e:
        print(f"ERROR: update_cart_item_quantity: {e}")
        return jsonify(success=False, message=f"Error updating cart quantity: {e}"), 500

@app.route('/remove_from_cart', methods=['POST'])
def remove_from_cart():
    try:
        data = request.get_json()
        item_id = data.get('itemId')

        if not item_id:
            return jsonify(success=False, message="Item ID is required."), 400

        current_cart_session = session.get('cart', {})
        if item_id in current_cart_session:
            del current_cart_session[item_id]
            session['cart'] = current_cart_session # Update session
            flash("Item removed from cart.", "info") # Flash message for removal
        else:
            return jsonify(success=False, message="Item not found in cart."), 404
        
        # Recalculate totals after removal
        artworks_data = load_artworks_data() # Use the specific loader
        updated_cart_summary = calculate_cart_totals(current_cart_session, artworks_data)

        return jsonify(success=True, message="Item removed.", **updated_cart_summary), 200

    except Exception as e:
        print(f"ERROR: remove_from_cart: {e}")
        return jsonify(success=False, message=f"Error removing item from cart: {e}"), 500


@app.route('/purchase-form', methods=['GET', 'POST'])
@login_required
def purchase_form():
    user = current_user
    artworks_data = load_artworks_data() # Use the specific loader

    if request.method == 'POST':
        # This branch is for direct 'Buy Now' or general checkout submission
        cart_json_str = request.form.get('cart_json')
        if not cart_json_str:
            flash('Your cart is empty. Please add items to proceed.', 'danger')
            return redirect(url_for('cart'))

        try:
            client_cart_items_list = json.loads(cart_json_str)
            # Convert list from client-side to a dict for calculate_cart_totals
            client_cart_dict = {item.get('id'): item for item in client_cart_items_list if item.get('id')}
        except json.JSONDecodeError:
            flash('Invalid cart data received. Please try again.', 'danger')
            return redirect(url_for('cart'))

        # Use the passed client_cart_dict for calculation and update session
        cart_summary = calculate_cart_totals(client_cart_dict, artworks_data)

        # If after processing, the cart is empty, redirect
        if not cart_summary['cart_items']:
            flash('Your cart is empty or all items are out of stock. Please add items to proceed.', 'info')
            return redirect(url_for('all_products'))

        # Proceed to create order
        orders = load_orders_data() # Use the specific loader
        new_order_id = str(uuid.uuid4())
        
        # Use the processed items from cart_summary for the order
        items_for_order = cart_summary['cart_items']

        new_order = {
            'order_id': new_order_id,
            'user_id': str(user.id),
            'user_email': user.email,
            'customer_name': request.form.get('name', user.name),
            'customer_phone': request.form.get('phone', user.phone),
            'customer_address': request.form.get('address', user.address),
            'customer_pincode': request.form.get('pincode', user.pincode),
            'items': items_for_order, # Use the processed items
            'subtotal_before_gst': cart_summary['subtotal_before_gst'],
            'total_gst_amount': cart_summary['total_gst_amount'],
            'shipping_charge': cart_summary['shipping_charge'], # Use the calculated shipping from backend
            'total_amount': cart_summary['grand_total'], # Grand total after all calculations
            'status': "Pending Payment",
            'transaction_id': None,
            'courier': None,
            'tracking_number': None,
            'placed_on': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'payment_submitted_on': None,
            'shipped_on': None,
            'remark': '', # Admin remark field
            'invoice_details': {
                'invoice_status': 'Not Applicable', # Default, will be 'Prepared' once admin processes
                'invoice_number': None,
                'invoice_date': None,
                'gst_rate_applied': DEFAULT_INVOICE_GST_RATE, # Default GST rate for invoice calculation
                'total_gst_amount': cart_summary['total_gst_amount'],
                'cgst_amount': cart_summary['total_gst_amount'] / 2, # Calculate CGST from total_gst_amount
                'sgst_amount': cart_summary['total_gst_amount'] / 2, # Calculate SGST from total_gst_amount
                'shipping_charge': cart_summary['shipping_charge'],
                'final_invoice_amount': cart_summary['grand_total'],
                'is_held_by_admin': False, # Flag to indicate if admin wants to manually review
                'customer_phone_camouflaged': user.phone # Store camouflaged phone for invoice if needed
            }
        }
        orders.append(new_order)
        save_json('orders.json', orders)

        # Update stock for purchased items
        updated_artworks = artworks_data # Start with current data
        for order_item in items_for_order:
            for artwork in updated_artworks:
                if artwork.get('sku') == order_item['sku']: # Use .get to prevent KeyError
                    artwork['stock'] = max(0, artwork.get('stock', 0) - order_item.get('quantity', 0))
                    break
        save_json('artworks.json', updated_artworks)

        session.pop('cart', None) # Clear server-side cart after order is placed
        flash('Your order has been placed successfully! Please complete the payment.', 'success')
        return redirect(url_for('payment_initiate', order_id=new_order_id, amount=new_order['total_amount']))

    else: # GET request to render the form
        cart_data_from_session = session.get('cart', {})

        if not isinstance(cart_data_from_session, dict):
            cart_data_from_session = {}
            session['cart'] = cart_data_from_session 

        if not cart_data_from_session: # If cart is empty on GET request
            flash('Your cart is empty. Please add items to proceed to checkout.', 'info')
            return redirect(url_for('cart'))

        # Recalculate totals based on current session cart for display
        cart_summary = calculate_cart_totals(cart_data_from_session, artworks_data)

        if not cart_summary['cart_items']: # If cart becomes empty after recalculation due to stock
            flash('Your cart is empty or all items are out of stock. Please add items to proceed.', 'info')
            return redirect(url_for('all_products'))

        context = {
            'prefill_name': user.name or '',
            'prefill_email': user.email or '',
            'prefill_email_type': 'text', # Always text if logged in, to show value
            'prefill_phone': user.phone or '',
            'prefill_address': user.address or '',
            'prefill_pincode': user.pincode or '',
            'cart_items': cart_summary['cart_items'], 
            'subtotal_before_gst': cart_summary['subtotal_before_gst'],
            'total_gst_amount': cart_summary['total_gst_amount'],
            'cgst_amount': cart_summary['cgst_amount'],
            'sgst_amount': cart_summary['sgst_amount'],
            'shipping_charge': cart_summary['shipping_charge'],
            'grand_total': cart_summary['grand_total'],
            'cart_json': json.dumps(cart_summary['cart_items']) # This passes the processed items back
        }
        return render_template('purchase-form.html', **context)


@app.route('/create_direct_order', methods=['POST'])
@login_required
def create_direct_order():
    try:
        data = request.get_json()
        client_cart = data.get('cart') # This 'cart' will contain only the one item for direct buy

        if not client_cart:
            return jsonify(success=False, message="No item provided for direct purchase."), 400

        user = current_user
        artworks_data = load_artworks_data() # Use the specific loader

        # Validate and process the single item from the client_cart
        # `calculate_cart_totals` expects a dict where keys are item_id
        temp_cart_dict = client_cart # This is already a dict from JS for single item

        cart_summary = calculate_cart_totals(temp_cart_dict, artworks_data)

        if not cart_summary['cart_items']:
            return jsonify(success=False, message="Item is out of stock or invalid."), 400

        # Proceed to create order with the single item
        orders = load_orders_data() # Use the specific loader
        new_order_id = str(uuid.uuid4())
        
        items_for_order = cart_summary['cart_items']

        new_order = {
            'order_id': new_order_id,
            'user_id': str(user.id),
            'user_email': user.email,
            'customer_name': user.name, # Prefill from logged-in user
            'customer_phone': user.phone,
            'customer_address': user.address,
            'customer_pincode': user.pincode,
            'items': items_for_order,
            'subtotal_before_gst': cart_summary['subtotal_before_gst'],
            'total_gst_amount': cart_summary['total_gst_amount'],
            'shipping_charge': cart_summary['shipping_charge'],
            'total_amount': cart_summary['grand_total'],
            'status': "Pending Payment",
            'transaction_id': None,
            'courier': None,
            'tracking_number': None,
            'placed_on': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'payment_submitted_on': None,
            'shipped_on': None,
            'remark': '',
            'invoice_details': {
                'invoice_status': 'Not Applicable',
                'invoice_number': None,
                'invoice_date': None,
                'gst_rate_applied': DEFAULT_INVOICE_GST_RATE,
                'total_gst_amount': cart_summary['total_gst_amount'],
                'cgst_amount': cart_summary['total_gst_amount'] / 2,
                'sgst_amount': cart_summary['total_gst_amount'] / 2,
                'shipping_charge': cart_summary['shipping_charge'],
                'final_invoice_amount': cart_summary['grand_total'],
                'is_held_by_admin': False,
                'customer_phone_camouflaged': user.phone
            }
        }
        orders.append(new_order)
        save_json('orders.json', orders)

        # Update stock for purchased item
        updated_artworks = artworks_data
        for order_item in items_for_order:
            for artwork in updated_artworks:
                if artwork.get('sku') == order_item['sku']:
                    artwork['stock'] = max(0, artwork.get('stock', 0) - order_item.get('quantity', 0))
                    break
        save_json('artworks.json', updated_artworks)

        # Redirect to payment initiation page
        redirect_url = url_for('payment_initiate', order_id=new_order_id, amount=new_order['total_amount'])
        return jsonify(success=True, message="Order placed successfully! Redirecting to payment.", redirect_url=redirect_url)

    except Exception as e:
        print(f"ERROR in create_direct_order: {e}")
        return jsonify(success=False, message=f"An error occurred: {e}"), 500


# Payment Initiate Page
@app.route('/payment-initiate/<order_id>/<float:amount>', methods=['GET'])
@login_required
def payment_initiate(order_id, amount):
    upi_id = "smarasada@okaxis" # Replace with your actual UPI ID
    banking_name = "SUBHASH S" # Replace with your actual banking name
    
    orders = load_orders_data() # Use the specific loader
    order = next((o for o o in orders if o['order_id'] == order_id), None)

    if not order:
        flash('Order not found. Please try again.', 'danger')
        return redirect(url_for('my_orders')) 

    # 'total_amount' in order now represents the final grand total after GST and shipping
    if abs(order.get('total_amount', 0.0) - amount) > 0.01: # Use a small tolerance for float comparison
        flash('Payment amount mismatch. Please try again or contact support.', 'danger')
        return redirect(url_for('my_orders'))

    context = {
        'order_id': order_id,
        'amount': amount,
        'upi_id': upi_id,
        'banking_name': banking_name
    }
    return render_template('payment-initiate.html', **context)

# Confirm Payment Details
@app.route('/confirm_payment', methods=['POST'])
@login_required
def confirm_payment():
    order_id = request.form.get('order_id')
    transaction_id = request.form.get('transaction_id')
    screenshot_file = request.files.get('screenshot')

    if not all([order_id, transaction_id]):
        flash('Order ID and Transaction ID are required.', 'danger')
        return redirect(url_for('my_orders')) 

    orders = load_orders_data() # Use the specific loader
    order_found = False
    screenshot_path = None

    if screenshot_file and screenshot_file.filename != '':
        try:
            os.makedirs(app.config['PAYMENT_SCREENSHOTS_FOLDER'], exist_ok=True)
            
            filename = str(uuid.uuid4()) + os.path.splitext(secure_filename(screenshot_file.filename))[1]
            screenshot_path_full = os.path.join(app.config['PAYMENT_SCREENSHOTS_FOLDER'], filename)
            screenshot_file.save(screenshot_path_full)
            screenshot_path = f'uploads/payment_screenshots/{filename}' 
        except Exception as e:
            print(f"ERROR: Failed to save screenshot: {e}")
            flash('Failed to upload screenshot. Please try again.', 'warning')


    for order in orders:
        if order.get('order_id') == order_id:
            order_found = True
            order['status'] = "Payment Submitted - Awaiting Verification"
            order['transaction_id'] = transaction_id
            if screenshot_path:
                order['payment_screenshot'] = screenshot_path
            order['payment_submitted_on'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            break

    if order_found:
        save_json('orders.json', orders)
        session.pop('cart', None) # Clear server-side cart after order is placed
        flash('Payment details submitted successfully. Your order status will be updated after verification.', 'success')
        response = make_response(redirect(url_for('thank_you_page')))
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    else:
        flash('Order not found. Please ensure you are submitting details for a valid order.', 'danger')
        return redirect(url_for('my_orders')) 

@app.route('/thank-you')
def thank_you_page():
    return render_template('thank-you.html')


# --- USER SPECIFIC ROUTES ---
@app.route('/my-orders')
@login_required
def my_orders():
    orders = load_orders_data() # Use the specific loader
    user_orders = []
    for order in orders:
        order['remark'] = order.get('remark', '') 
        if str(order.get('user_id')) == str(current_user.id):
            user_orders.append(order)

    return render_template('my_orders.html', orders=user_orders)

@app.route('/cancel-order/<order_id>', methods=['POST'])
@login_required
def cancel_order(order_id):
    orders = load_orders_data() # Use the specific loader
    order_found = False
    
    for order_idx, order in enumerate(orders): # Use enumerate to get index for direct modification
        if order.get('order_id') == order_id:
            # Security check: Ensure the current logged-in user owns this order
            if str(order.get('user_id')) == str(current_user.id):
                # Only allow cancellation if the order is in a "cancellable" state
                if order.get('status') in ["Pending Payment", "Payment Submitted - Awaiting Verification"]:
                    orders[order_idx]['status'] = "Cancelled by User" # Update using index
                    # Also update invoice status if it exists
                    if 'invoice_details' in orders[order_idx]:
                        orders[order_idx]['invoice_details']['invoice_status'] = 'Cancelled'
                        orders[order_idx]['invoice_details']['is_held_by_admin'] = True # Prevent automatic sending if cancelled
                    save_json('orders.json', orders)
                    flash(f"Order {order_id} has been cancelled.", "success")
                else:
                    flash(f"Order {order_id} cannot be cancelled at its current status ({order.get('status')}). Please contact support.", "danger")
                order_found = True
                break
            else:
                flash("You do not have permission to cancel this order.", "danger")
                order_found = True # Found the order, but not owned by current user
                break
    
    if not order_found:
        flash(f"Order {order_id} not found.", "danger")
    
    return redirect(url_for('my_orders'))


@app.route('/user-dashboard')
@login_required
def user_dashboard():
    return render_template('user_dashboard.html')

@app.route('/profile')
@login_required
def profile():
    user_info = {
        'name': current_user.name,
        'email': current_user.email,
        'phone': current_user.phone,
        'address': current_user.address,
        'pincode': current_user.pincode,
        'role': current_user.role
    }
    return render_template('profile.html', user_info=user_info)


# --- Admin Routes ---

@app.route('/admin')
@admin_required
def admin_panel():
    orders = load_orders_data() # Use the specific loader
    artworks = load_artworks_data() # Use the specific loader
    return render_template('admin_panel.html', orders=orders, artworks=artworks)

@app.route('/admin/artworks')
@admin_required
def admin_artworks_view():
    artworks = load_artworks_data() # Use the specific loader
    return render_template('admin_artworks_view.html', artworks=artworks)

@app.route('/admin/orders')
@admin_required
def admin_orders_view():
    orders = load_orders_data() # Use the specific loader
    
    # Filtering Logic
    filter_status = request.args.get('status')
    filter_invoice_status = request.args.get('invoice_status')
    search_query = request.args.get('search_query', '').lower()

    filtered_orders = []
    for order in orders:
        match_status = True
        if filter_status and order.get('status') != filter_status:
            match_status = False
        
        match_invoice_status = True
        invoice_det = order.get('invoice_details', {})
        if filter_invoice_status and invoice_det.get('invoice_status') != filter_invoice_status:
            match_invoice_status = False

        match_search = True
        if search_query:
            order_id = order.get('order_id', '').lower()
            customer_name = order.get('customer_name', '').lower()
            customer_email = order.get('user_email', '').lower()
            if not (search_query in order_id or search_query in customer_name or search_query in customer_email):
                match_search = False

        if match_status and match_invoice_status and match_search:
            filtered_orders.append(order)
    
    # Sort orders by placed_on date in descending order
    filtered_orders.sort(key=lambda x: datetime.strptime(x['placed_on'], "%Y-%m-%d %H:%M:%S"), reverse=True)

    return render_template('admin_orders_view.html', 
                           orders=filtered_orders,
                           current_filter_status=filter_status,
                           current_filter_invoice_status=filter_invoice_status,
                           current_search_query=search_query)

@app.route('/admin/order/update', methods=['POST'])
@admin_required
def admin_orders_update():
    order_id = request.form.get('order_id')
    new_status = request.form.get('status')
    courier = request.form.get('courier')
    tracking_number = request.form.get('tracking_number')

    orders = load_orders_data() # Use the specific loader
    order_found = False
    for order in orders:
        if order.get('order_id') == order_id:
            order['status'] = new_status
            order['courier'] = courier if new_status == 'Shipped' else None
            order['tracking_number'] = tracking_number if new_status == 'Shipped' else None
            if new_status == 'Shipped' and not order.get('shipped_on'):
                order['shipped_on'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            elif new_status != 'Shipped':
                order['shipped_on'] = None # Clear shipped_on if status changes from Shipped
            
            # If order is shipped and not held, set invoice status to 'Prepared'
            if new_status == 'Shipped' and not order.get('invoice_details', {}).get('is_held_by_admin', False):
                # Ensure invoice_details exists
                if 'invoice_details' not in order:
                    order['invoice_details'] = {}
                order['invoice_details']['invoice_status'] = 'Prepared'
            
            save_json('orders.json', orders)
            flash(f'Order {order_id} status updated to {new_status}.', 'success')
            order_found = True
            break
    if not order_found:
        flash(f'Order {order_id} not found.', 'danger')
    return redirect(url_for('admin_orders_view'))

@app.route('/admin/order/remark', methods=['POST'])
@admin_required
def admin_add_remark():
    try:
        data = request.get_json()
        order_id = data.get('order_id')
        remark_text = data.get('remark')

        orders = load_orders_data() # Use the specific loader
        order_found = False
        for order in orders:
            if order.get('order_id') == order_id:
                order['remark'] = remark_text # Update the remark field
                save_json('orders.json', orders)
                flash(f"Remark for Order {order_id} updated.", "success")
                order_found = True
                return jsonify(success=True, message=f"Remark for Order {order_id} updated.", remark=remark_text)
        if not order_found:
            flash(f"Order {order_id} not found.", "danger")
            return jsonify(success=False, message="Order not found."), 404
    except Exception as e:
        print(f"ERROR in admin_add_remark: {e}")
        flash(f"An error occurred: {e}", "danger")
        return jsonify(success=False, message=f"An error occurred: {e}"), 500


@app.route('/admin/invoice/edit/<order_id>', methods=['GET', 'POST'])
@admin_required
def admin_edit_invoice(order_id):
    orders = load_orders_data() # Use the specific loader
    order = next((o for o in orders if o['order_id'] == order_id), None)

    if not order:
        flash('Order not found.', 'danger')
        return redirect(url_for('admin_orders_view'))

    # Ensure invoice_details structure exists and has default values
    if 'invoice_details' not in order:
        order['invoice_details'] = {}
    
    invoice_det = order['invoice_details']
    invoice_det.setdefault('business_name', OUR_BUSINESS_NAME)
    invoice_det.setdefault('gst_number', OUR_GSTIN)
    invoice_det.setdefault('pan_number', OUR_PAN)
    invoice_det.setdefault('business_address', OUR_BUSINESS_ADDRESS)
    invoice_det.setdefault('customer_phone_camouflaged', order.get('customer_phone', 'N/A'))
    invoice_det.setdefault('invoice_number', str(uuid.uuid4())[:8].upper() if order.get('status') == 'Shipped' else None)
    invoice_det.setdefault('invoice_date', datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
    invoice_det.setdefault('billing_address', order.get('customer_address', 'N/A'))
    invoice_det.setdefault('gst_rate_applied', DEFAULT_INVOICE_GST_RATE)
    invoice_det.setdefault('total_gst_amount', 0.0)
    invoice_det.setdefault('cgst_amount', 0.0)
    invoice_det.setdefault('sgst_amount', 0.0)
    invoice_det.setdefault('shipping_charge', order.get('shipping_charge', 0.0))
    invoice_det.setdefault('final_invoice_amount', order.get('total_amount', 0.0))
    invoice_det.setdefault('invoice_status', 'Not Applicable' if order.get('status') != 'Shipped' else 'Prepared')
    invoice_det.setdefault('is_held_by_admin', False)
    invoice_det.setdefault('invoice_pdf_path', None)
    invoice_det.setdefault('invoice_email_sent_on', None)


    if request.method == 'POST':
        try:
            # Update business details
            invoice_det['business_name'] = request.form['business_name']
            invoice_det['gst_number'] = request.form['gst_number']
            invoice_det['pan_number'] = request.form['pan_number']
            invoice_det['business_address'] = request.form['business_address']

            # Update invoice details
            invoice_det['invoice_number'] = request.form['invoice_number']
            invoice_det['invoice_date'] = datetime.fromisoformat(request.form['invoice_date']).strftime("%Y-%m-%d %H:%M:%S")
            invoice_det['billing_address'] = request.form['billing_address']

            # Update financial details and recalculate
            gst_rate_applied = float(request.form['gst_rate'])
            shipping_charge = float(request.form['shipping_charge'])

            # Recalculate based on current item subtotal_before_gst from order and new rates
            base_subtotal = order.get('subtotal_before_gst', 0.0)
            
            total_gst_amount_recalc = base_subtotal * (gst_rate_applied / 100)
            cgst_amount_recalc = total_gst_amount_recalc / 2
            sgst_amount_recalc = total_gst_amount_recalc / 2
            final_invoice_amount_recalc = base_subtotal + total_gst_amount_recalc + shipping_charge

            invoice_det['gst_rate_applied'] = round(gst_rate_applied, 2)
            invoice_det['total_gst_amount'] = round(total_gst_amount_recalc, 2)
            invoice_det['cgst_amount'] = round(cgst_amount_recalc, 2)
            invoice_det['sgst_amount'] = round(sgst_amount_recalc, 2)
            invoice_det['shipping_charge'] = round(shipping_charge, 2)
            invoice_det['final_invoice_amount'] = round(final_invoice_amount_recalc, 2)
            
            # If status was 'Prepared' or 'Sent', and is now edited, mark as 'Edited'
            if invoice_det.get('invoice_status') in ['Prepared', 'Sent']:
                invoice_det['invoice_status'] = 'Edited'
            
            # Set to held if it was sent and now edited, for review
            if invoice_det.get('invoice_status') == 'Edited' and not invoice_det.get('is_held_by_admin'):
                invoice_det['is_held_by_admin'] = True # Automatically hold if edited after sending

            save_json('orders.json', orders)
            flash(f'Invoice details for Order {order_id} updated successfully.', 'success')
            return redirect(url_for('admin_orders_view'))

        except Exception as e:
            flash(f'Error updating invoice: {e}', 'danger')
            print(f"Error in admin_edit_invoice: {e}")

    return render_template('admin_edit_invoice.html', order=order)

@app.route('/admin/invoice/hold/<order_id>', methods=['POST'])
@admin_required
def admin_hold_invoice(order_id):
    orders = load_orders_data() # Use the specific loader
    order_found = False
    for order in orders:
        if order.get('order_id') == order_id:
            if 'invoice_details' not in order:
                order['invoice_details'] = {}
            order['invoice_details']['is_held_by_admin'] = True
            order['invoice_details']['invoice_status'] = 'Held'
            save_json('orders.json', orders)
            flash(f'Invoice for Order {order_id} put on HOLD.', 'success')
            order_found = True
            break
    if not order_found:
        flash(f'Order {order_id} not found.', 'danger')
    return jsonify(success=True, message=f'Invoice for Order {order_id} put on HOLD.') # Return JSON for AJAX

@app.route('/admin/invoice/release/<order_id>', methods=['POST'])
@admin_required
def admin_release_invoice(order_id):
    orders = load_orders_data() # Use the specific loader
    order_found = False
    for order in orders:
        if order.get('order_id') == order_id:
            if 'invoice_details' not in order:
                order['invoice_details'] = {}
            order['invoice_details']['is_held_by_admin'] = False
            # Revert status to Prepared if order is Shipped, otherwise Not Applicable
            order['invoice_details']['invoice_status'] = 'Prepared' if order.get('status') == 'Shipped' else 'Not Applicable'
            save_json('orders.json', orders)
            flash(f'Invoice for Order {order_id} RELEASED.', 'success')
            order_found = True
            break
    if not order_found:
        flash(f'Order {order_id} not found.', 'danger')
    return jsonify(success=True, message=f'Invoice for Order {order_id} RELEASED.') # Return JSON for AJAX


@app.route('/admin/invoice/send_email/<order_id>', methods=['POST'])
@admin_required
def admin_send_invoice_email(order_id):
    # This is a placeholder. In a real app, you would integrate with an email service
    # and attach the generated PDF.
    orders = load_orders_data() # Use the specific loader
    order = next((o for o in orders if o['order_id'] == order_id), None)

    if not order:
        return jsonify(success=False, message=f'Order {order_id} not found.'), 404
    
    if order.get('invoice_details', {}).get('is_held_by_admin'):
        return jsonify(success=False, message=f'Invoice for Order {order_id} is on HOLD by admin. Release it first.'), 400

    if order.get('invoice_details', {}).get('invoice_status') == 'Sent':
        return jsonify(success=False, message=f'Invoice for Order {order_id} has already been sent.'), 400

    # Simulate email sending process
    try:
        # In a real app:
        # 1. Generate PDF if not already generated (or regenerate if edited)
        #    generate_invoice_pdf(order_id) # Need to implement this function
        # 2. Use an email library (e.g., Flask-Mail, smtplib) to send email
        #    with subject "Your Karthika Futures Invoice - Order [order_id]"
        #    and attach the PDF.
        #    Example:
        #    msg = Message("Your Karthika Futures Invoice", sender=OUR_BUSINESS_EMAIL, recipients=[order['user_email']])
        #    msg.body = f"Dear {order['customer_name']},\n\nPlease find your invoice for Order {order_id} attached.\n\nThank you for your purchase!\nKarthika Futures"
        #    with app.open_resource(order['invoice_details']['invoice_pdf_path']) as fp:
        #        msg.attach(f"invoice_{order_id}.pdf", "application/pdf", fp.read())
        #    mail.send(msg)

        # For now, just update status and flash message
        if 'invoice_details' not in order:
            order['invoice_details'] = {}
        order['invoice_details']['invoice_status'] = 'Sent'
        order['invoice_details']['invoice_email_sent_on'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        save_json('orders.json', orders)
        flash(f'Invoice email for Order {order_id} sent successfully to {order["user_email"]}.', 'success')
        return jsonify(success=True, message=f'Invoice email for Order {order_id} sent successfully.')
    except Exception as e:
        print(f"Error sending invoice email for order {order_id}: {e}")
        if 'invoice_details' not in order:
            order['invoice_details'] = {}
        order['invoice_details']['invoice_status'] = 'Email Failed'
        save_json('orders.json', orders)
        flash(f'Failed to send invoice email for Order {order_id}. Error: {e}', 'danger')
        return jsonify(success=False, message=f'Failed to send invoice email for Order {order_id}. Error: {e}'), 500


@app.route('/admin/download_invoice/<order_id>')
@admin_required
def download_invoice(order_id):
    orders = load_orders_data() # Use the specific loader
    order = next((o for o in orders if o['order_id'] == order_id), None)

    if not order:
        flash('Order not found.', 'danger')
        return redirect(url_for('admin_orders_view'))

    invoice_path = order.get('invoice_details', {}).get('invoice_pdf_path')
    # Check if path exists and ensure it's within the static/uploads directory for security
    if invoice_path and invoice_path.startswith('uploads/invoices/'):
        full_path = os.path.join(app.root_path, 'static', invoice_path)
        if os.path.exists(full_path):
            return send_file(full_path, as_attachment=True, download_name=f"invoice_{order_id}.pdf", mimetype='application/pdf')
    
    flash(f'Invoice PDF not found or path invalid for Order {order_id}. Please generate it first.', 'warning')
    return redirect(url_for('admin_edit_invoice', order_id=order_id))


@app.route('/delete_order/<order_id>', methods=['GET'])
@admin_required
def delete_order(order_id):
    orders = load_orders_data() # Use the specific loader
    original_len = len(orders)
    orders = [order for order in orders if order.get('order_id') != order_id]
    if len(orders) < original_len:
        save_json('orders.json', orders)
        flash(f'Order {order_id} deleted successfully.', 'success')
    else:
        flash(f'Order {order_id} not found.', 'danger')
    return redirect(url_for('admin_orders_view'))


@app.route('/add_artwork', methods=['GET', 'POST'])
@admin_required
def add_artwork():
    categories = load_categories_data() # Use the specific loader
    if request.method == 'POST':
        sku = request.form['sku'].strip()
        name = request.form['name'].strip()
        category = request.form['category']
        original_price = float(request.form['original_price'])
        stock = int(request.form['stock'])
        description = request.form.get('description', '').strip()
        gst_percentage = float(request.form.get('gst_percentage', DEFAULT_GST_PERCENTAGE))

        # Handle optional pricing for Paintings category
        size_a4 = float(request.form.get('size_a4', 0.0))
        size_a5 = float(request.form.get('size_a5', 0.0))
        size_letter = float(request.form.get('size_letter', 0.0))
        size_legal = float(request.form.get('size_legal', 0.0))
        frame_wooden = float(request.form.get('frame_wooden', 0.0))
        frame_metal = float(request.form.get('frame_metal', 0.0))
        frame_pvc = float(request.form.get('frame_pvc', 0.0))
        glass_price = float(request.form.get('glass_price', 0.0))

        artworks = load_artworks_data() # Use the specific loader

        # Check for duplicate SKU
        if any(a['sku'] == sku for a in artworks):
            flash('Artwork with this SKU already exists. Please use a unique SKU.', 'danger')
            return render_template('add_artwork.html', categories=categories, artwork=request.form)

        image_filenames = []
        if 'images' in request.files:
            for file in request.files.getlist('images'):
                if file and file.filename:
                    filename = secure_filename(file.filename)
                    unique_filename = str(uuid.uuid4()) + '_' + filename
                    file_path = os.path.join(app.config['PRODUCT_IMAGES_FOLDER'], unique_filename)
                    file.save(file_path)
                    image_filenames.append(f'uploads/product_images/{unique_filename}')
        
        # Ensure at least one image (placeholder if none uploaded)
        if not image_filenames:
            image_filenames.append('images/placeholder.png') # Default placeholder

        new_artwork = {
            'sku': sku,
            'name': name,
            'category': category,
            'original_price': original_price,
            'stock': stock,
            'description': description,
            'gst_percentage': gst_percentage,
            'images': image_filenames,
            'size_a4': size_a4,
            'size_a5': size_a5,
            'size_letter': size_letter,
            'size_legal': size_legal,
            'frame_wooden': frame_wooden,
            'frame_metal': frame_metal,
            'frame_pvc': frame_pvc,
            'glass_price': glass_price,
            'is_featured': False # Default to not featured
        }
        artworks.append(new_artwork)
        save_json('artworks.json', artworks)
        flash(f'Artwork "{name}" added successfully!', 'success')
        return redirect(url_for('admin_artworks_view'))
    return render_template('add_artwork.html', categories=categories)

@app.route('/edit_artwork/<sku>', methods=['GET', 'POST'])
@admin_required
def edit_artwork(sku):
    artworks = load_artworks_data() # Use the specific loader
    artwork = next((a for a in artworks if a['sku'] == sku), None)
    if not artwork:
        flash('Artwork not found.', 'danger')
        return redirect(url_for('admin_artworks_view'))

    categories = load_categories_data() # Use the specific loader

    if request.method == 'POST':
        # Update artwork details
        artwork['name'] = request.form['name'].strip()
        artwork['category'] = request.form['category']
        artwork['original_price'] = float(request.form['original_price'])
        artwork['stock'] = int(request.form['stock'])
        artwork['description'] = request.form.get('description', '').strip()
        artwork['gst_percentage'] = float(request.form.get('gst_percentage', DEFAULT_GST_PERCENTAGE))
        artwork['is_featured'] = 'is_featured' in request.form # Check if checkbox is ticked

        # Handle optional pricing for Paintings category, ensure they are reset if category changes
        if artwork['category'] == 'Paintings':
            artwork['size_a4'] = float(request.form.get('size_a4', 0.0))
            artwork['size_a5'] = float(request.form.get('size_a5', 0.0))
            artwork['size_letter'] = float(request.form.get('size_letter', 0.0))
            artwork['size_legal'] = float(request.form.get('size_legal', 0.0))
            artwork['frame_wooden'] = float(request.form.get('frame_wooden', 0.0))
            artwork['frame_metal'] = float(request.form.get('frame_metal', 0.0))
            artwork['frame_pvc'] = float(request.form.get('frame_pvc', 0.0))
            artwork['glass_price'] = float(request.form.get('glass_price', 0.0))
        else: # Reset these values if category is not 'Paintings'
            artwork['size_a4'] = 0.0
            artwork['size_a5'] = 0.0
            artwork['size_letter'] = 0.0
            artwork['size_legal'] = 0.0
            artwork['frame_wooden'] = 0.0
            artwork['frame_metal'] = 0.0
            artwork['frame_pvc'] = 0.0
            artwork['glass_price'] = 0.0

        # Handle image uploads (add new images, retain existing ones)
        new_image_filenames = artwork.get('images', []) # Start with existing images
        if 'images' in request.files:
            for file in request.files.getlist('images'):
                if file and file.filename:
                    filename = secure_filename(file.filename)
                    unique_filename = str(uuid.uuid4()) + '_' + filename
                    file_path = os.path.join(app.config['PRODUCT_IMAGES_FOLDER'], unique_filename)
                    file.save(file_path)
                    new_image_filenames.append(f'uploads/product_images/{unique_filename}')
        artwork['images'] = new_image_filenames
        
        # If no images after edit, fallback to placeholder
        if not artwork['images']:
            artwork['images'] = ['images/placeholder.png']


        save_json('artworks.json', artworks)
        flash(f'Artwork "{artwork["name"]}" updated successfully!', 'success')
        return redirect(url_for('admin_artworks_view'))
    
    return render_template('edit_artwork.html', artwork=artwork, categories=categories)

@app.route('/delete_artwork/<sku>', methods=['GET'])
@admin_required
def delete_artwork(sku):
    artworks = load_artworks_data() # Use the specific loader
    original_len = len(artworks)
    artworks = [a for a in artworks if a.get('sku') != sku]
    if len(artworks) < original_len:
        save_json('artworks.json', artworks)
        flash(f'Artwork with SKU {sku} deleted successfully.', 'success')
    else:
        flash(f'Artwork with SKU {sku} not found.', 'danger')
    return redirect(url_for('admin_artworks_view'))


@app.route('/admin/categories')
@admin_required
def admin_categories_view():
    categories = load_categories_data() # Use the specific loader
    return render_template('admin_categories_view.html', categories=categories)

@app.route('/admin/category/add', methods=['POST'])
@admin_required
def admin_add_category():
    name = request.form['name'].strip()
    description = request.form.get('description', '').strip()
    image_file = request.files.get('image')

    categories = load_categories_data() # Use the specific loader
    if any(c['name'].lower() == name.lower() for c in categories):
        flash('Category with this name already exists.', 'danger')
        return redirect(url_for('admin_categories_view'))

    image_path = None
    if image_file and image_file.filename:
        filename = secure_filename(image_file.filename)
        unique_filename = str(uuid.uuid4()) + '_' + filename
        file_path = os.path.join(app.config['CATEGORY_IMAGES_FOLDER'], unique_filename)
        image_file.save(file_path)
        image_path = f'uploads/category_images/{unique_filename}'
    else:
        image_path = 'images/placeholder.png' # Default placeholder for category image

    new_category = {
        'id': str(uuid.uuid4()),
        'name': name,
        'description': description,
        'image': image_path
    }
    categories.append(new_category)
    save_json('categories.json', categories)
    flash(f'Category "{name}" added successfully!', 'success')
    return redirect(url_for('admin_categories_view'))

@app.route('/admin/category/edit/<category_id>', methods=['GET', 'POST'])
@admin_required
def admin_edit_category(category_id):
    categories = load_categories_data() # Use the specific loader
    category = next((c for c in categories if c['id'] == category_id), None)
    if not category:
        flash('Category not found.', 'danger')
        return redirect(url_for('admin_categories_view'))

    if request.method == 'POST':
        category['name'] = request.form['name'].strip()
        category['description'] = request.form.get('description', '').strip()

        image_file = request.files.get('image')
        if image_file and image_file.filename:
            filename = secure_filename(image_file.filename)
            unique_filename = str(uuid.uuid4()) + '_' + filename
            file_path = os.path.join(app.config['CATEGORY_IMAGES_FOLDER'], unique_filename)
            image_file.save(file_path)
            category['image'] = f'uploads/category_images/{unique_filename}'
        # If no new image, retain existing. If no existing and no new, use placeholder handled by template.

        save_json('categories.json', categories)
        flash(f'Category "{category["name"]}" updated successfully!', 'success')
        return redirect(url_for('admin_categories_view'))
    return render_template('admin_edit_category.html', category=category)


@app.route('/admin/category/delete/<category_id>', methods=['POST'])
@admin_required
def admin_delete_category(category_id):
    categories = load_json('categories.json')
    original_len = len(categories)
    categories = [c for c in categories if c.get('id') != category_id]
    if len(categories) < original_len:
        save_json('categories.json', categories)
        flash('Category deleted successfully.', 'success')
    else:
        flash('Category not found.', 'danger')
    return redirect(url_for('admin_categories_view'))

# --- User Authentication Routes ---
@app.route('/signup', methods=['GET', 'POST'])
def signup():
    if current_user.is_authenticated:
        return redirect(url_for('index')) # Already logged in
    
    if request.method == 'POST':
        name = request.form['name']
        email = request.form['email']
        password = request.form['password']
        phone = request.form['phone']
        address = request.form['address']
        pincode = request.form['pincode']

        users = load_users_data() # Use the specific loader
        if User.find_by_email(email):
            flash('Email already registered. Please login or use a different email.', 'danger')
            return render_template('signup.html', form_data=request.form)

        hashed_password = generate_password_hash(password)
        new_user = User(id=uuid.uuid4(), email=email, password=hashed_password, name=name, phone=phone, address=address, pincode=pincode, role='user').__dict__
        users.append(new_user)
        save_json('users.json', users)
        flash('Account created successfully! Please log in.', 'success')
        return redirect(url_for('user_login'))
    return render_template('signup.html')


@app.route('/user_login', methods=['GET', 'POST'])
def user_login():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        user = User.find_by_email(email)

        if user and check_password_hash(user.password, password):
            login_user(user)
            flash('Logged in successfully!', 'success')
            next_page = request.args.get('next')
            return redirect(next_page or url_for('index'))
        else:
            flash('Invalid email or password.', 'danger')
    return render_template('user_login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    session.pop('cart', None) # Clear cart on logout
    flash('You have been logged out.', 'info')
    return redirect(url_for('index'))

@app.route('/admin_login', methods=['GET', 'POST'])
def admin_login():
    if current_user.is_authenticated and current_user.is_admin():
        return redirect(url_for('admin_panel'))
    
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        user = User.find_by_email(email)

        if user and user.is_admin() and check_password_hash(user.password, password):
            login_user(user)
            flash('Admin logged in successfully!', 'success')
            return redirect(url_for('admin_panel'))
        else:
            flash('Invalid admin credentials.', 'danger')
    return render_template('admin_login.html')

@app.route('/admin_logout')
@login_required
@admin_required # Only admin can use this specific logout
def admin_logout():
    logout_user()
    session.pop('cart', None) # Clear cart on admin logout too
    flash('Admin has been logged out.', 'info')
    return redirect(url_for('admin_login'))


# --- Initial Admin User Creation (Run Once) ---
@app.cli.command('create-admin')
def create_admin():
    """Creates an initial admin user."""
    users = load_users_data() # Use the specific loader
    if any(u['role'] == 'admin' for u in users):
        print("Admin user already exists.")
        return

    admin_email = input("Enter admin email: ")
    admin_password = input("Enter admin password: ")
    admin_name = input("Enter admin name (e.g., Admin User): ")

    hashed_password = generate_password_hash(admin_password)
    new_admin = User(id=uuid.uuid4(), email=admin_email, password=hashed_password, name=admin_name, role='admin').__dict__
    users.append(new_admin)
    save_json('users.json', users)
    print(f"Admin user '{admin_email}' created successfully!")
    print("Run `flask run` to start the application.")

# --- Background Task Simulation for Invoices (Manual Trigger for now) ---
# In a real application, this would be a scheduled task (e.g., Celery, cron job)
@app.route('/admin/process-invoices', methods=['GET'])
@admin_required
def process_pending_invoices():
    orders = load_orders_data() # Use the specific loader
    artworks_data = load_artworks_data() # Use the specific loader
    processed_count = 0

    for order in orders:
        if order.get('status') == 'Shipped' and \
           order.get('invoice_details', {}).get('invoice_status') == 'Prepared' and \
           not order.get('invoice_details', {}).get('is_held_by_admin', False):
            try:
                # Re-calculate final amounts for invoice (in case artwork prices/GST changed since order)
                # This ensures the invoice reflects the exact rates at the time of invoice generation/email
                
                # Create a temporary cart for the order's items to use calculate_cart_totals
                # Note: `calculate_cart_totals` expects a dict-like cart, so we convert the order's items list
                # This also helps in validating stock and adjusting quantities if needed *before* generating invoice.
                temp_order_cart_items_dict = {item.get('id'): item for item in order.get('items', []) if item.get('id')}
                recalculated_summary = calculate_cart_totals(temp_order_cart_items_dict, artworks_data)

                # Update order's invoice_details with latest calculated figures and our business details
                invoice_details = order.get('invoice_details', {}) # Get existing or create new dict
                
                invoice_details['invoice_number'] = invoice_details.get('invoice_number') or str(uuid.uuid4())[:8].upper()
                invoice_details['invoice_date'] = invoice_details.get('invoice_date') or datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                invoice_details['gst_rate_applied'] = DEFAULT_INVOICE_GST_RATE # Use current default GST rate for invoice
                invoice_details['total_gst_amount'] = recalculated_summary['total_gst_amount']
                invoice_details['cgst_amount'] = recalculated_summary['cgst_amount']
                invoice_details['sgst_amount'] = recalculated_summary['sgst_amount']
                invoice_details['shipping_charge'] = recalculated_summary['shipping_charge']
                invoice_details['final_invoice_amount'] = recalculated_summary['grand_total']
                
                invoice_details['business_name'] = OUR_BUSINESS_NAME
                invoice_details['gst_number'] = OUR_GSTIN
                invoice_details['pan_number'] = OUR_PAN
                invoice_details['business_address'] = OUR_BUSINESS_ADDRESS

                order['invoice_details'] = invoice_details # Update the order's invoice_details

                # Generate and save PDF (placeholder for actual PDF generation)
                invoice_filename = f"invoice_{order['order_id']}.pdf"
                invoice_pdf_path_full = os.path.join(app.config['INVOICE_PDF_FOLDER'], invoice_filename)
                invoice_pdf_path_relative = f'uploads/invoices/{invoice_filename}'

                # Simulate PDF generation: just create an empty file for now
                with open(invoice_pdf_path_full, 'w') as f:
                    f.write(f"Simulated PDF for Order {order['order_id']}") # In real app, generate actual PDF content

                order['invoice_details']['invoice_pdf_path'] = invoice_pdf_path_relative
                
                order['invoice_details']['invoice_status'] = 'Prepared' # Keep as prepared, admin can manually send
                processed_count += 1

            except Exception as e:
                print(f"Error processing invoice for order {order.get('order_id')}: {e}")
                if 'invoice_details' not in order:
                    order['invoice_details'] = {}
                order['invoice_details']['invoice_status'] = 'PDF Gen Failed' # Mark as failed
                flash(f"Failed to process invoice for order {order.get('order_id')}. Error: {e}", 'danger')
    
    if processed_count > 0:
        save_json('orders.json', orders)
        flash(f'Processed {processed_count} pending invoices. Please review and send.', 'info')
    else:
        flash('No pending invoices to process.', 'info')

    return redirect(url_for('admin_orders_view')) # Redirect back to admin orders view


if __name__ == '__main__':
    # Ensure 'data' directory exists at startup
    os.makedirs('data', exist_ok=True)
    app.run(debug=True)
